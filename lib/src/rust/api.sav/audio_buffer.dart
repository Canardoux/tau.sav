// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            // These functions are ignored because they are not marked as `pub`: `create_xaudio_buffer`


            

            
                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBuffer>>
                abstract class AudioBuffer implements RustOpaqueInterface {
                     XAudioBuffer get myBuffer;


 void set myBuffer(XAudioBuffer myBuffer);


/// Copy data from a given channel to the given `Vec`
///
/// # Panics
///
/// This function will panic if `channel_number` is greater or equal than
/// `AudioBuffer::number_of_channels()`
 Future<void>  copyFromChannel({required F32 destination , required BigInt channelNumber });


/// Copy data from a given channel to the given `Vec` starting at `offset`
///
/// # Panics
///
/// This function will panic if:
/// - the given channel number is greater than or equal to the given number of channels.
 Future<void>  copyFromChannelWithOffset({required F32 destination , required BigInt channelNumber , required BigInt offset });


/// Copy data from a given source to the given channel.
///
/// # Panics
///
/// This function will panic if:
/// - the given channel number is greater than or equal to the given number of channels.
 Future<void>  copyToChannel({required List<double> source , required BigInt channelNumber });


/// Copy data from a given source to the given channel starting at `offset`.
///
/// # Panics
///
/// This function will panic if:
/// - the given channel number is greater than or equal to the given number of channels.
 Future<void>  copyToChannelWithOffset({required List<double> source , required BigInt channelNumber , required BigInt offset });


/// Duration in seconds of the `AudioBuffer`
 Future<double>  duration();


static AudioBuffer  from({required List<Float32List> samples , required double sampleRate })=>RustLib.instance.api.crateApiAudioBufferAudioBufferFrom(samples: samples, sampleRate: sampleRate);


/// Return a read-only copy of the underlying data of the channel
///
/// # Panics
///
/// This function will panic if:
/// - the given channel number is greater than or equal to the given number of channels.
 Future<void>  getChannelData({required BigInt channelNumber });


/// Return a mutable slice of the underlying data of the channel
///
/// # Panics
///
/// This function will panic if:
/// - the given channel number is greater than or equal to the given number of channels.
 Future<void>  getChannelDataMut({required BigInt channelNumber });


/// Number of samples per channel in this `AudioBuffer`
 Future<BigInt>  length();


factory AudioBuffer({required AudioBufferOptions options })=>RustLib.instance.api.crateApiAudioBufferAudioBufferNew(options: options);


static AudioBuffer  newFromXaudioBuffer({required XAudioBuffer buf })=>RustLib.instance.api.crateApiAudioBufferAudioBufferNewFromXaudioBuffer(buf: buf);


/// Number of channels in this `AudioBuffer`
 Future<BigInt>  numberOfChannels();


/// Sample rate of this `AudioBuffer` in Hertz
 Future<double>  sampleRate();



                    
                }
                


                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<XAudioBuffer>>
                abstract class XAudioBuffer implements RustOpaqueInterface {
                    

                    
                }
                

class AudioBufferOptions  {
                /// The number of channels for the buffer
final BigInt numberOfChannels;
/// The length in sample frames of the buffer
final BigInt length;
/// The sample rate in Hz for the buffer
final double sampleRate;

                const AudioBufferOptions({required this.numberOfChannels ,required this.length ,required this.sampleRate ,});

                
                

                
        @override
        int get hashCode => numberOfChannels.hashCode^length.hashCode^sampleRate.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is AudioBufferOptions &&
                runtimeType == other.runtimeType
                && numberOfChannels == other.numberOfChannels&& length == other.length&& sampleRate == other.sampleRate;
        
            }
            