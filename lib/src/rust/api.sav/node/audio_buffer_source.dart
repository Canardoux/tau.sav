// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../third_party/web_audio_api.dart';
import '../../third_party/web_audio_api/node.dart';
import '../../third_party/web_audio_api/worklet.dart';
import '../audio_buffer.dart';
import '../audio_context.dart';
import 'audio_node.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            

            

            
                // Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>
                abstract class AudioBufferSourceNode implements RustOpaqueInterface, AudioNode, AudioNode, AudioScheduledSourceNode {
                    /// Current buffer value (nullable)
 Future<AudioBuffer?>  buffer();


/// Config for up/down-mixing of input channels for this node.
///
/// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
 Future<void>  channelConfig();


/// Represents an integer used to determine how many channels are used when up-mixing and
/// down-mixing connections to any inputs to the node.
 Future<BigInt>  channelCount();


/// Represents an enumerated value describing the way channels must be matched between the
/// node's inputs and outputs.
 Future<ChannelCountMode>  channelCountMode();


/// Represents an enumerated value describing the meaning of the channels. This interpretation
/// will define how audio up-mixing and down-mixing will happen.
 Future<ChannelInterpretation>  channelInterpretation();


/// Unset the callback to run when the source node has stopped playing
 Future<void>  clearOnended();


/// Unset the callback to run when an unhandled exception occurs in the audio processor.
 Future<void>  clearOnprocessorerror();


/// Connect the output of this AudioNode to the input of another node.
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
 Future<void>  connect({required AudioNode dest });


/// Connect a specific output of this AudioNode to a specific input of another node.
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
/// - if the input port is out of bounds for the destination node
/// - if the output port is out of bounds for the source node
 Future<void>  connectFromOutputToInput({required AudioNode dest , required BigInt output , required BigInt input });


/// The [`BaseAudioContext`](crate::context::BaseAudioContext) concrete type which owns this
/// AudioNode.
 Future<void>  context();


/// K-rate [`AudioParam`] that defines a pitch transposition of the file,
/// expressed in cents
///
/// see <https://en.wikipedia.org/wiki/Cent_(music)>
 Future<void>  detune();


/// Disconnects all outgoing connections from the AudioNode.
 Future<void>  disconnect();


/// Disconnects all outputs of the AudioNode that go to a specific destination AudioNode.
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
/// - the source node was not connected to the destination node
 Future<void>  disconnectDest({required AudioNode dest });


/// Disconnects a specific output of the AudioNode to a specific destination AudioNode
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
/// - if the output port is out of bounds for the source node
/// - the source node was not connected to the destination node
 Future<void>  disconnectDestFromOutput({required AudioNode dest , required BigInt output });


/// Disconnects a specific output of the AudioNode to a specific input of some destination
/// AudioNode
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
/// - if the input port is out of bounds for the destination node
/// - if the output port is out of bounds for the source node
/// - the source node was not connected to the destination node
 Future<void>  disconnectDestFromOutputToInput({required AudioNode dest , required BigInt output , required BigInt input });


/// Disconnects all outgoing connections at the given output port from the AudioNode.
///
/// # Panics
///
/// This function will panic when
/// - if the output port is out of bounds for this node
 Future<void>  disconnectOutput({required BigInt output });


 void  getXNode();


/// Defines if the playback the [`AudioBuffer`] should be looped
 Future<bool>  loop();


/// Defines the loop end point, in the time reference of the [`AudioBuffer`]
 Future<double>  loopEnd();


/// Defines the loop start point, in the time reference of the [`AudioBuffer`]
 Future<double>  loopStart();


factory AudioBufferSourceNode({required AudioContext context , required AudioBufferSourceOptions options })=>RustLib.instance.api.crateApiNodeAudioBufferSourceAudioBufferSourceNodeNew(context: context, options: options);


/// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
 Future<BigInt>  numberOfInputs();


/// The number of outputs coming out of the AudioNode.
 Future<BigInt>  numberOfOutputs();


/// K-rate [`AudioParam`] that defines the speed at which the [`AudioBuffer`]
/// will be played, e.g.:
/// - `0.5` will play the file at half speed
/// - `-1` will play the file in reverse
///
/// Note that playback rate will also alter the pitch of the [`AudioBuffer`]
 Future<void>  playbackRate();


/// Current playhead position in seconds within the [`AudioBuffer`].
///
/// This value is updated at the end of each render quantum.
///
/// Unofficial v2 API extension, not part of the spec yet.
/// See also: <https://github.com/WebAudio/web-audio-api/issues/2397#issuecomment-709478405>
 Future<double>  position();


/// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
///
/// Only when implementing the AudioNode trait manually, this struct is of any concern.
 Future<void>  registration();


/// Provide an [`AudioBuffer`] as the source of data to be played bask
///
/// # Panics
///
/// Panics if a buffer has already been given to the source (though `new` or through
/// `set_buffer`)
 Future<void>  setBuffer({required AudioBuffer audioBuffer });


/// Update the `channel_count` attribute
 Future<void>  setChannelCount({required BigInt v });


/// Update the `channel_count_mode` attribute
 Future<void>  setChannelCountMode({required ChannelCountMode v });


/// Update the `channel_interpretation` attribute
 Future<void>  setChannelInterpretation({required ChannelInterpretation v });


 Future<void>  setLoop({required bool value });


 Future<void>  setLoopEnd({required double value });


 Future<void>  setLoopStart({required double value });


/// Register callback to run when an unhandled exception occurs in the audio processor.
///
/// Note that once a unhandled exception is thrown, the processor will output silence throughout its lifetime.
///
/// Only a single event handler is active at any time. Calling this method multiple times will
/// override the previous event handler.
 Future<void>  setOnprocessorerror({required BoxFnOnceErrorEvent callback });


 void  start();


/// Schedule playback start at given timestamp
///
/// # Panics
///
/// Panics if the source was already started
 Future<void>  startAt({required double when });


/// Start the playback at the given time and with a given offset
///
/// # Panics
///
/// Panics if the source was already started
 Future<void>  startAtWithOffset({required double start , required double offset });


/// Start the playback at the given time, with a given offset, for a given duration
///
/// # Panics
///
/// Panics if the source was already started
 Future<void>  startAtWithOffsetAndDuration({required double start , required double offset , required double duration });


/// Stop immediately
///
/// # Panics
///
/// Panics if the source was already stopped
 Future<void>  stop();


/// Schedule playback stop at given timestamp
///
/// # Panics
///
/// Panics if the source was already stopped
 Future<void>  stopAt({required double when });



                    
                }
                

class AudioBufferSourceOptions  {
                final AudioBuffer? buffer;
final double detune;
final bool loop;
final double loopStart;
final double loopEnd;
final double playbackRate;

                const AudioBufferSourceOptions({this.buffer ,required this.detune ,required this.loop ,required this.loopStart ,required this.loopEnd ,required this.playbackRate ,});

                static AudioBufferSourceOptions  def()=>RustLib.instance.api.crateApiNodeAudioBufferSourceAudioBufferSourceOptionsDef();


                

                
        @override
        int get hashCode => buffer.hashCode^detune.hashCode^loop.hashCode^loopStart.hashCode^loopEnd.hashCode^playbackRate.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is AudioBufferSourceOptions &&
                runtimeType == other.runtimeType
                && buffer == other.buffer&& detune == other.detune&& loop == other.loop&& loopStart == other.loopStart&& loopEnd == other.loopEnd&& playbackRate == other.playbackRate;
        
            }
            