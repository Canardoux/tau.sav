// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.40.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../third_party/web_audio_api.dart';
import '../../third_party/web_audio_api/node.dart';
import '../../third_party/web_audio_api/worklet.dart';
import 'audio_buffer_source.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';


            

            

            class AudioDestinationNode  {
                final AudioDestinationNode xAudioDestinationNode;

                const AudioDestinationNode({required this.xAudioDestinationNode ,});

                /// Config for up/down-mixing of input channels for this node.
///
/// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
 Future<void>  channelConfig()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeChannelConfig(that: this, );


/// Represents an integer used to determine how many channels are used when up-mixing and
/// down-mixing connections to any inputs to the node.
 Future<BigInt>  channelCount()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeChannelCount(that: this, );


/// Represents an enumerated value describing the way channels must be matched between the
/// node's inputs and outputs.
 Future<ChannelCountMode>  channelCountMode()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeChannelCountMode(that: this, );


/// Represents an enumerated value describing the meaning of the channels. This interpretation
/// will define how audio up-mixing and down-mixing will happen.
 Future<ChannelInterpretation>  channelInterpretation()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeChannelInterpretation(that: this, );


/// Unset the callback to run when an unhandled exception occurs in the audio processor.
 Future<void>  clearOnprocessorerror()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeClearOnprocessorerror(that: this, );


/// Connect the output of this AudioNode to the input of another node.
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
 Future<void>  connect({required AudioNode dest })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeConnect(that: this, dest: dest);


/// Connect a specific output of this AudioNode to a specific input of another node.
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
/// - if the input port is out of bounds for the destination node
/// - if the output port is out of bounds for the source node
 Future<void>  connectFromOutputToInput({required AudioNode dest , required BigInt output , required BigInt input })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeConnectFromOutputToInput(that: this, dest: dest, output: output, input: input);


/// The [`BaseAudioContext`](crate::context::BaseAudioContext) concrete type which owns this
/// AudioNode.
 Future<void>  context()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeContext(that: this, );


/// Disconnects all outgoing connections from the AudioNode.
 Future<void>  disconnect()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeDisconnect(that: this, );


/// Disconnects all outputs of the AudioNode that go to a specific destination AudioNode.
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
/// - the source node was not connected to the destination node
 Future<void>  disconnectDest({required AudioNode dest })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeDisconnectDest(that: this, dest: dest);


/// Disconnects a specific output of the AudioNode to a specific destination AudioNode
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
/// - if the output port is out of bounds for the source node
/// - the source node was not connected to the destination node
 Future<void>  disconnectDestFromOutput({required AudioNode dest , required BigInt output })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeDisconnectDestFromOutput(that: this, dest: dest, output: output);


/// Disconnects a specific output of the AudioNode to a specific input of some destination
/// AudioNode
///
/// # Panics
///
/// This function will panic when
/// - the AudioContext of the source and destination does not match
/// - if the input port is out of bounds for the destination node
/// - if the output port is out of bounds for the source node
/// - the source node was not connected to the destination node
 Future<void>  disconnectDestFromOutputToInput({required AudioNode dest , required BigInt output , required BigInt input })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeDisconnectDestFromOutputToInput(that: this, dest: dest, output: output, input: input);


/// Disconnects all outgoing connections at the given output port from the AudioNode.
///
/// # Panics
///
/// This function will panic when
/// - if the output port is out of bounds for this node
 Future<void>  disconnectOutput({required BigInt output })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeDisconnectOutput(that: this, output: output);


 void  getXNode()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeGetXNode(that: this, );


/// The maximum number of channels that the channelCount attribute can be set to (the max
/// number of channels that the hardware is capable of supporting).
/// <https://www.w3.org/TR/webaudio/#dom-audiodestinationnode-maxchannelcount>
 Future<BigInt>  maxChannelCount()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeMaxChannelCount(that: this, );


/// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
 Future<BigInt>  numberOfInputs()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeNumberOfInputs(that: this, );


/// The number of outputs coming out of the AudioNode.
 Future<BigInt>  numberOfOutputs()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeNumberOfOutputs(that: this, );


/// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
///
/// Only when implementing the AudioNode trait manually, this struct is of any concern.
 Future<void>  registration()=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeRegistration(that: this, );


/// Update the `channel_count` attribute
 Future<void>  setChannelCount({required BigInt v })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeSetChannelCount(that: this, v: v);


/// Update the `channel_count_mode` attribute
 Future<void>  setChannelCountMode({required ChannelCountMode v })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeSetChannelCountMode(that: this, v: v);


/// Update the `channel_interpretation` attribute
 Future<void>  setChannelInterpretation({required ChannelInterpretation v })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeSetChannelInterpretation(that: this, v: v);


/// Register callback to run when an unhandled exception occurs in the audio processor.
///
/// Note that once a unhandled exception is thrown, the processor will output silence throughout its lifetime.
///
/// Only a single event handler is active at any time. Calling this method multiple times will
/// override the previous event handler.
 Future<void>  setOnprocessorerror({required BoxFnOnceErrorEvent callback })=>RustLib.instance.api.crateApiNodeAudioDestinationNodeAudioDestinationNodeSetOnprocessorerror(that: this, callback: callback);


                

                
        @override
        int get hashCode => xAudioDestinationNode.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is AudioDestinationNode &&
                runtimeType == other.runtimeType
                && xAudioDestinationNode == other.xAudioDestinationNode;
        
            }
            